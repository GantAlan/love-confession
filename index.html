<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Pixel Love (Editable)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, sans-serif; touch-action: none; }
        #canvas-box { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* 调试日志 (默认隐藏) */
        #debug-console {
            position: fixed; top: 0; left: 0; width: 100%; height: 60px;
            background: rgba(0,0,0,0.5); color: #00ff00; font-family: monospace;
            font-size: 10px; padding: 5px; overflow-y: auto; z-index: 9999;
            pointer-events: none; display: none;
        }

        /* --- UI 组件 --- */
        
        /* 设置按钮 */
        #gear-btn {
            position: fixed; top: 20px; left: 20px; z-index: 50;
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2); color: white;
            font-size: 24px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        /* 设置面板 */
        #settings-panel {
            position: fixed; top: 80px; left: 20px; width: 240px; /*稍微加宽以容纳文本框*/
            background: rgba(20, 20, 30, 0.9); backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 16px;
            padding: 15px; color: white; z-index: 49;
            transform: translateX(-150%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            max-height: 70vh; overflow-y: auto; /* 防止内容过长 */
        }
        #settings-panel.active { transform: translateX(0); }

        .control-group { margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 15px; }
        .control-group:last-child { border-bottom: none; }
        .control-label { font-size: 12px; color: #aaa; margin-bottom: 8px; display: block; font-weight: bold; }
        
        /* 新增：文本域样式 */
        textarea {
            width: 100%; background: rgba(0,0,0,0.3); border: 1px solid #555;
            color: #fff; border-radius: 8px; padding: 8px; font-size: 14px;
            resize: vertical; font-family: inherit; box-sizing: border-box;
            outline: none;
        }
        textarea:focus { border-color: #00e5ff; }

        /* 新增：全屏按钮样式 */
        .setting-btn {
            width: 100%; padding: 10px; background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
            color: white; cursor: pointer; font-size: 14px; transition: background 0.2s;
        }
        .setting-btn:active { background: rgba(255,255,255,0.25); }

        /* 颜色选择器布局 */
        .color-row { display: flex; gap: 10px; }
        input[type="color"] {
            flex: 1; height: 36px; border: none; border-radius: 6px; 
            padding: 0; background: none; cursor: pointer;
        }

        /* 滑块样式 */
        input[type="range"] {
            width: 100%; -webkit-appearance: none; background: rgba(255,255,255,0.2);
            height: 4px; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%;
            background: #fff; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }

        /* 启动层 */
        #start-overlay {
            position: fixed; inset: 0; background: #050505; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; color: white;
            background-image: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        }
        
        .big-btn {
            background: linear-gradient(135deg, #00e5ff, #ff0088);
            border: none; padding: 18px 40px; border-radius: 50px;
            color: white; font-size: 18px; font-weight: bold; margin-top: 30px;
            box-shadow: 0 0 25px rgba(0, 229, 255, 0.4);
            cursor: pointer; transition: transform 0.2s;
        }
        .big-btn:active { transform: scale(0.95); }

        .skip-link {
            margin-top: 25px; color: #666; font-size: 14px; 
            text-decoration: underline; background: none; border: none;
        }

        /* 视频预览 */
        #cam-preview {
            position: fixed; bottom: 10px; right: 10px; width: 80px;
            z-index: 50; border: 1px solid rgba(255,255,255,0.3); 
            transform: scaleX(-1); opacity: 0.6; border-radius: 8px;
            background: #000;
        }

        /* 底部按钮 */
        #ui-layer {
            position: fixed; bottom: 40px; width: 100%; text-align: center; z-index: 20;
            pointer-events: none;
        }
        #next-btn {
            pointer-events: auto;
            padding: 14px 40px; background: rgba(255,255,255,0.1); 
            border: 1px solid rgba(255,255,255,0.25); backdrop-filter: blur(8px);
            color: white; border-radius: 30px; font-size: 16px; font-weight: 600;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="debug-console">System Ready.<br></div>

    <div id="gear-btn">⚙️</div>

    <div id="settings-panel">
        <div class="control-group">
            <label class="control-label">显示选项</label>
            <button id="fullscreen-btn" class="setting-btn">⛶ 切换全屏显示</button>
        </div>

        <div class="control-group">
            <label class="control-label">编辑文字 (每行一句五个字以内)<br>张开手掌 = 文字<br>捏合手指 = 星空</label>
            <textarea id="msg-input" rows="5" placeholder="输入你想说的话..."></textarea>
            <div style="font-size:10px; color:#666; margin-top:5px;">修改后点击下方的“下一句”生效</div>
        </div>

        <div class="control-group">
            <label class="control-label">渐变颜色</label>
            <div class="color-row">
                <input type="color" id="col-a" value="#00e5ff">
                <input type="color" id="col-b" value="#ff0088">
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">方块大小</label>
            <input type="range" id="size-range" min="0.01" max="1.0" step="0.01" value="0.5">
        </div>

      
    </div>

    <div id="start-overlay">
        <div style="font-size: 50px; margin-bottom: 10px;">❤️</div>
        <h1 style="margin: 0; font-weight: 300;">3D Pixel Love</h1>
        <p style="color:#888; font-size:12px; margin-top: 10px;">HTTPS Required | iOS Safari Recommended</p>
        <button class="big-btn" id="start-btn">点击启动摄像头</button>
        <button class="skip-link" id="skip-btn">无法启动？点此跳过</button>
    </div>

    <video id="cam-preview" playsinline muted autoplay></video>
    <div id="canvas-box"></div>
    
    <div id="ui-layer">
        <button id="next-btn">下一句 ✨</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 日志 ---
        function log(msg) {
            const el = document.getElementById('debug-console');
            el.innerHTML += `> ${msg}<br>`;
            console.log(msg);
        }

        // --- 配置 ---
        // 注意：这里使用 let 以便后续修改
        const MESSAGES = ["Ready?", "Hi ", "看这里", "张开手", "给你看", "我的", "❤️"];
        const CONFIG = { count: 16000 }; 

        let scene, camera, renderer, mesh;
        let currentMsgIndex = 0;
        let handExpansion = 1.0; 
        let targetExpansion = 1.0;
        let isCameraRunning = false;

        const state = {
            cubeSize: 0.6,
            colA: new THREE.Color('#00e5ff'),
            colB: new THREE.Color('#ff0088')
        };

        // --- 1. Three.js ---
        function initThree() {
            log("Init 3D...");
            const container = document.getElementById('canvas-box');
            scene = new THREE.Scene();
            scene.background = new THREE.Color('#050505');

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
            adjustCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            createParticles();
            
            setTimeout(() => {
                currentMsgIndex = 1;
                updateText(MESSAGES[currentMsgIndex]);
            }, 500);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                adjustCameraPosition();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            bindUIControls(); 
            animate();
        }

        function adjustCameraPosition() {
            camera.position.z = window.innerWidth < window.innerHeight ? 18 : 14;
        }

        // --- 2. 粒子 ---
        const data = { 
            target: new Float32Array(CONFIG.count * 3), 
            scatter: new Float32Array(CONFIG.count * 3) 
        };

        function createParticles() {
            for(let i=0; i<CONFIG.count; i++) {
                const r = 10 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                data.scatter[i*3] = r * Math.sin(phi) * Math.cos(theta);
                data.scatter[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                data.scatter[i*3+2] = r * Math.cos(phi) * 0.5;
            }

            const geo = new THREE.InstancedBufferGeometry();
            const base = new THREE.BoxGeometry(1, 1, 1);
            geo.index = base.index;
            geo.attributes.position = base.attributes.position;
            geo.attributes.normal = base.attributes.normal;
            
            geo.setAttribute('aTarget', new THREE.InstancedBufferAttribute(data.target, 3));
            geo.setAttribute('aScatter', new THREE.InstancedBufferAttribute(data.scatter, 3));
            
            const rands = new Float32Array(CONFIG.count);
            for(let i=0; i<CONFIG.count; i++) rands[i] = Math.random();
            geo.setAttribute('aRandom', new THREE.InstancedBufferAttribute(rands, 1));

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uExp: { value: 1.0 },
                    uSize: { value: state.cubeSize }, 
                    uColA: { value: state.colA },
                    uColB: { value: state.colB }
                },
                vertexShader: `
                    uniform float uTime; uniform float uExp; uniform float uSize; 
                    uniform vec3 uColA; uniform vec3 uColB;
                    attribute vec3 aTarget; attribute vec3 aScatter; attribute float aRandom;
                    varying vec3 vColor;
                    
                    mat4 rot(vec3 axis, float angle) {
                        axis = normalize(axis);
                        float s = sin(angle); float c = cos(angle); float oc = 1.0 - c;
                        return mat4(oc*axis.x*axis.x+c, oc*axis.x*axis.y-axis.z*s, oc*axis.z*axis.x+axis.y*s, 0.0,
                                    oc*axis.x*axis.y+axis.z*s, oc*axis.y*axis.y+c, oc*axis.y*axis.z-axis.x*s, 0.0,
                                    oc*axis.z*axis.x-axis.y*s, oc*axis.y*axis.z+axis.x*s, oc*axis.z*axis.z+c, 0.0,
                                    0.0, 0.0, 0.0, 1.0);
                    }

                    void main() {
                        float smoothExp = smoothstep(0.0, 1.0, uExp);
                        vec3 pos = mix(aTarget, aScatter, smoothExp);
                        pos += vec3(sin(uTime*3.0+aRandom*10.0)*0.1*smoothExp);
                        mat4 rm = rot(normalize(vec3(aRandom,1.0,0.0)), uTime*(1.0+smoothExp*2.0) + aRandom*10.0);
                        vec3 p = position * uSize; 
                        p = (rm * vec4(p, 1.0)).xyz + pos;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
                        float grad = smoothstep(-6.0, 6.0, pos.x);
                        vec3 c = mix(uColA, uColB, grad);
                        vec3 n = (rm * vec4(normal, 0.0)).xyz;
                        float l = max(dot(n, normalize(vec3(0.5,1.0,1.0))), 0.3);
                        vColor = c * (l + 0.4);
                    }
                `,
                fragmentShader: `varying vec3 vColor; void main(){ gl_FragColor = vec4(vColor,1.0); }`
            });

            mesh = new THREE.Mesh(geo, mat);
            mesh.frustumCulled = false;
            scene.add(mesh);
        }

        function updateText(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 500; canvas.height = 250;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,500,250);
            ctx.fillStyle = '#fff'; ctx.font = '900 100px sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 250, 125);
            
            const imgData = ctx.getImageData(0,0,500,250).data;
            const pts = [];
            for(let y=0; y<250; y+=4) {
                for(let x=0; x<500; x+=4) {
                    if(imgData[(y*500+x)*4]>100) pts.push((x-250)*0.045, -(y-125)*0.045, 0);
                }
            }
            const attr = mesh.geometry.attributes.aTarget;
            for(let i=0; i<CONFIG.count; i++) {
                if(pts.length===0) break;
                const p = i % (pts.length/3);
                attr.setXYZ(i, pts[p*3], pts[p*3+1], pts[p*3+2] + (Math.random()-0.5)*0.5);
            }
            attr.needsUpdate = true;
        }

        // --- 3. UI 控制逻辑 (更新版) ---
        function bindUIControls() {
            // 面板开关
            const gearBtn = document.getElementById('gear-btn');
            const panel = document.getElementById('settings-panel');
            gearBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                panel.classList.toggle('active');
            });
            document.addEventListener('click', (e) => {
                if(!panel.contains(e.target) && e.target !== gearBtn) {
                    panel.classList.remove('active');
                }
            });

            // 1. 全屏功能
            const fsBtn = document.getElementById('fullscreen-btn');
            fsBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        alert("无法全屏: " + err.message);
                    });
                } else {
                    document.exitFullscreen();
                }
            });

            // 2. 文字编辑 (Textarea)
            const msgInput = document.getElementById('msg-input');
            msgInput.value = MESSAGES.join('\n'); // 初始化显示默认文字
            msgInput.addEventListener('input', () => {
                const text = msgInput.value;
                const newMsgs = text.split('\n').map(t => t.trim()).filter(t => t.length > 0);
                if(newMsgs.length > 0) {
                    MESSAGES.length = 0; // 清空数组
                    MESSAGES.push(...newMsgs); // 压入新内容
                    if(currentMsgIndex >= MESSAGES.length) currentMsgIndex = 0;
                }
            });

            // 3. 颜色控制
            document.getElementById('col-a').addEventListener('input', (e) => state.colA.set(e.target.value));
            document.getElementById('col-b').addEventListener('input', (e) => state.colB.set(e.target.value));

            // 4. 大小控制
            document.getElementById('size-range').addEventListener('input', (e) => {
                state.cubeSize = parseFloat(e.target.value);
                if(mesh) mesh.material.uniforms.uSize.value = state.cubeSize;
            });
        }

        // --- 4. 摄像头 & AI ---
        async function startCameraSystem() {
            log("启动摄像头流程...");
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("浏览器不支持 getUserMedia");
                return;
            }

            const video = document.getElementById('cam-preview');
            let stream = null;

            try {
                try {
                    stream = await navigator.mediaDevices.getUserMedia({
                        audio: false, video: { facingMode: 'user', width: { ideal: 320 }, height: { ideal: 240 } }
                    });
                } catch (e) {
                    log("高清失败，尝试标清...");
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: 'user' } });
                    } catch (e2) {
                        log("前置失败，尝试任意...");
                        stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });
                    }
                }

                if (!stream) throw new Error("无法获取流");
                video.srcObject = stream;
                
                try { await video.play(); } catch(err) { log("Play error: " + err.message); }
                
                log("加载 MediaPipe...");
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({
                    maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
                });
                
                hands.onResults(onHandResults);

                async function loop() {
                    if (video.readyState >= 2) await hands.send({image: video});
                    if(isCameraRunning) requestAnimationFrame(loop);
                }
                
                isCameraRunning = true;
                loop();
                document.getElementById('start-overlay').style.display = 'none';

            } catch (err) {
                let msg = err.name === 'NotReadableError' ? "摄像头被占用" : err.message;
                alert("启动失败: " + msg + "\n已切换到触摸模式");
                document.getElementById('start-overlay').style.display = 'none';
                enableTouchMode();
            }
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const d = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                let val = THREE.MathUtils.smoothstep(d, 0.02, 0.2);
                targetExpansion = 1.0 - val;
            }
        }

        function enableTouchMode() {
            log("启用触摸模式");
            const handle = (y) => targetExpansion = THREE.MathUtils.clamp(y, 0, 1);
            document.addEventListener('mousemove', (e) => handle(e.clientY/window.innerHeight));
            document.addEventListener('touchmove', (e) => handle(e.touches[0].clientY/window.innerHeight), {passive:true});
        }

        function animate() {
            requestAnimationFrame(animate);
            handExpansion += (targetExpansion - handExpansion) * 0.1;
            
            if(mesh) {
                mesh.material.uniforms.uTime.value = performance.now()*0.001;
                mesh.material.uniforms.uExp.value = handExpansion;
                mesh.material.uniforms.uColA.value = state.colA;
                mesh.material.uniforms.uColB.value = state.colB;
                mesh.material.uniforms.uSize.value = state.cubeSize;
            }
            scene.rotation.y = Math.sin(performance.now()*0.0002) * 0.1;
            renderer.render(scene, camera);
        }

        document.getElementById('start-btn').addEventListener('click', startCameraSystem);
        document.getElementById('skip-btn').addEventListener('click', () => {
            document.getElementById('start-overlay').style.display = 'none';
            enableTouchMode();
        });
        document.getElementById('next-btn').addEventListener('click', () => {
            currentMsgIndex = (currentMsgIndex + 1) % MESSAGES.length;
            // 确保在 MESSAGES 改变后这里也能读到正确的文字
            if(MESSAGES.length > 0) updateText(MESSAGES[currentMsgIndex]);
        });

        initThree();

    </script>
</body>
</html>
